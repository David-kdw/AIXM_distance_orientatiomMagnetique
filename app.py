# -*- coding: utf-8 -*-
"""Ce programme a été écrit par KUDAWOO Séna Kodjovi, Cadre SIA-AIM à la Direction générale de l'ASECNA à Dakar
il permet de traiter une dataset AIXM de données de routes ATS pour calculer les distances et les orientations magnétiques des sections de route

Automatically generated by Colaboratory.

"""

import pandas as pd
from geomag import declination
from geopy.distance import geodesic
from flask import Flask, render_template, request, jsonify, redirect, send_from_directory, url_for

import datetime
import math
import xml.etree.ElementTree as ET
import pandas as pd
import os

app = Flask(__name__)
app.secret_key = "supersecretkey"

comments = []

@app.route('/')
def home():
  return render_template('index.html', comments=comments)


@app.route('/add_comment', methods=['POST'])
def add_comment():
    pseudo = request.form.get('pseudo')
    text = request.form.get('comment')

    if pseudo and text:
        comment_id = len(comments) + 1
        comments.append({"id": comment_id, "pseudo": pseudo, "text": text, "replies": []})
    
    return redirect(url_for('home'))

@app.route('/reply_comment/<int:parent_id>', methods=['POST'])
def reply_comment(parent_id):
    pseudo = request.form.get('pseudo')
    reply_text = request.form.get('reply_text')

    for comment in comments:
        if comment['id'] == parent_id:
            comment['replies'].append({"pseudo": pseudo, "text": reply_text})
            break

    return redirect(url_for('home'))

@app.route('/edit_comment/<int:comment_id>', methods=['GET', 'POST'])
def edit_comment(comment_id):
    if request.method == 'POST':
        new_text = request.form.get('comment')
        for comment in comments:
            if comment['id'] == comment_id and comment['pseudo'] == session.get('pseudo'):
                comment['text'] = new_text
                break
        return redirect(url_for('home'))

    return render_template('edit_comment.html', comment_id=comment_id)

@app.route('/delete_comment/<int:comment_id>')
def delete_comment(comment_id):
    global comments
    comments = [c for c in comments if c['id'] != comment_id or c['pseudo'] == session.get('pseudo') or session.get('is_admin')]
    return redirect(url_for('home'))

@app.route('/upload_unit')
def upload_form():
    return render_template('unit_calc.html')

@app.route('/upload_data')
def upload_forms():
    return render_template('dataset_calc.html')


@app.route('/process_data', methods=['POST'])
def process_data():
    # Vérifiez si un fichier a été téléchargé
    if 'xml_file' not in request.files:
        return 'Aucun fichier téléchargé'
    
    xml_file = request.files['xml_file']
    
    # Vérifiez si le fichier a un nom et une extension valides (par exemple, .xml)
    if xml_file.filename == '':
        return 'Nom de fichier vide'
    if not xml_file.filename.endswith('.xml'):
        return 'Extension de fichier non valide'
    
    # Récupérez la date de référence saisie par l'utilisateur
    date_ref = request.form['date_ref']
    try:
        # Convertissez la date de référence en objet date
        magDateRef = datetime.datetime.strptime(date_ref, '%Y-%m-%d').date()
    except ValueError:
        return 'Format de date de référence invalide'

    # Enregistrez le fichier XML dans un répertoire temporaire
    xml_filename = os.path.join('temp', xml_file.filename)
    xml_file.save(xml_filename)
    
    # Chargez le fichier XML et effectuez le traitement des données
    tree = ET.parse(xml_filename)
    root = tree.getroot()

    # Créez une liste pour stocker les données
    data = []

    # Itérez sur les éléments "Rsg" dans le fichier XML
    for rsg in root.findall(".//Rsg"):
        # Créez un dictionnaire pour stocker les données de chaque élément
        rsg_data = {}

        rsg_uid = rsg.find('RsgUid')
        if rsg_uid is not None:
            rsg_data['RsgUid'] = rsg_uid.get('mid')

            rte_uid = rsg_uid.find('RteUid')
            if rte_uid is not None:
                rsg_data['RteUid'] = rte_uid.get('mid')
                rsg_data['txtDesig'] = rte_uid.find('txtDesig').text
                rsg_data['txtLocDesig'] = rte_uid.find('txtLocDesig').text

            dpn_uid_sta = rsg_uid.find('DpnUidSta')
            ndb_uid_sta = rsg_uid.find('NdbUidSta')
            vor_uid_sta = rsg_uid.find('VorUidSta')
            if dpn_uid_sta is not None:
                rsg_data['DpnUidSta'] = dpn_uid_sta.get('mid')
                rsg_data['codeIdSta'] = dpn_uid_sta.find('codeId').text
                rsg_data['geoLatSta'] = dpn_uid_sta.find('geoLat').text
                rsg_data['geoLongSta'] = dpn_uid_sta.find('geoLong').text
            if ndb_uid_sta is not None:
                rsg_data['NdbUidSta'] = ndb_uid_sta.get('mid')
                rsg_data['codeIdSta'] = ndb_uid_sta.find('codeId').text
                rsg_data['geoLatSta'] = ndb_uid_sta.find('geoLat').text
                rsg_data['geoLongSta'] = ndb_uid_sta.find('geoLong').text
            if vor_uid_sta is not None:
                rsg_data['VorUidSta'] = vor_uid_sta.get('mid')
                rsg_data['codeIdSta'] = vor_uid_sta.find('codeId').text
                rsg_data['geoLatSta'] = vor_uid_sta.find('geoLat').text
                rsg_data['geoLongSta'] = vor_uid_sta.find('geoLong').text

            dpn_uid_end = rsg_uid.find('DpnUidEnd')
            ndb_uid_end = rsg_uid.find('NdbUidEnd')
            vor_uid_end = rsg_uid.find('VorUidEnd')
            if dpn_uid_end is not None:
                rsg_data['DpnUidEnd'] = dpn_uid_end.get('mid')
                rsg_data['codeIdEnd'] = dpn_uid_end.find('codeId').text
                rsg_data['geoLatEnd'] = dpn_uid_end.find('geoLat').text
                rsg_data['geoLongEnd'] = dpn_uid_end.find('geoLong').text
            if ndb_uid_end is not None:
                rsg_data['NdbUidEnd'] = ndb_uid_end.get('mid')
                rsg_data['codeIdEnd'] = ndb_uid_end.find('codeId').text
                rsg_data['geoLatEnd'] = ndb_uid_end.find('geoLat').text
                rsg_data['geoLongEnd'] = ndb_uid_end.find('geoLong').text
            if vor_uid_end is not None:
                rsg_data['VorUidEnd'] = vor_uid_end.get('mid')
                rsg_data['codeIdEnd'] = vor_uid_end.find('codeId').text
                rsg_data['geoLatEnd'] = vor_uid_end.find('geoLat').text
                rsg_data['geoLongEnd'] = vor_uid_end.find('geoLong').text

            rsg_data['codeType'] = rsg.find('codeType').text
            rsg_data['codeLvl'] = rsg.find('codeLvl').text
            val_dist_vert = rsg.find('valDistVerUpper')
            if val_dist_vert is not None:
              rsg_data['valDistVerUpper'] = rsg.find('valDistVerUpper').text
            uom_dist_ver_upper = rsg.find('uomDistVerUpper')
            if uom_dist_ver_upper is not None:
              rsg_data['uomDistVerUpper'] = rsg.find('uomDistVerUpper').text
            code_dist_ver_upper = rsg.find('codeDistVerUpper')
            if code_dist_ver_upper is not None:
              rsg_data['codeDistVerUpper'] = rsg.find('codeDistVerUpper').text
            val_dist_ver_lower = rsg.find('valDistVerLower')
            if val_dist_ver_lower is not None :
              rsg_data['valDistVerLower'] = rsg.find('valDistVerLower').text
            uom_dist_ver_lower = rsg.find('uomDistVerLower')
            if uom_dist_ver_lower is not None :
              rsg_data['uomDistVerLower'] = rsg.find('uomDistVerLower').text
            code_dist_ver_lower = rsg.find('codeDistVerLower')
            if code_dist_ver_lower is not None:
              rsg_data['codeDistVerLower'] = rsg.find('codeDistVerLower').text
            val_wid = rsg.find('valWid')
            if val_wid is not None:
              rsg_data['valWid'] = rsg.find('valWid').text
            uom_wid = rsg.find('uomWid')
            if uom_wid is not None:
              rsg_data['uomWid'] = rsg.find('uomWid').text
            code_atc_start = rsg.find('codeRepAtcStart')
            if code_atc_start is not None:
              rsg_data['codeRepAtcStart'] = rsg.find('codeRepAtcStart').text
            code_atc_end= rsg.find('codeRepAtcEnd')
            if code_atc_end is not None:
              rsg_data['codeRepAtcEnd'] = rsg.find('codeRepAtcEnd').text
            val_mag_track = rsg.find('valMagTrack')
            if val_mag_track is not None:
              rsg_data['valMagTrack'] = int(rsg.find('valMagTrack').text)
            val_reverse_mag_track = rsg.find('valReversMagTrack')
            if val_reverse_mag_track is not None:
              rsg_data['valReversMagTrack'] = int(rsg.find('valReversMagTrack').text)
            val_len = rsg.find('valLen')
            if val_len is not None:
              rsg_data['valLen'] = str(int(float(rsg.find('valLen').text)))
            uom_len_dist = rsg.find('uomDist')
            if uom_len_dist is not None:
              rsg_data['uomDist'] = rsg.find('uomDist').text

            # Ajoutez le dictionnaire à la liste de données
            data.append(rsg_data)

    # Créez un DataFrame pandas à partir des données
    dfview = pd.DataFrame(data)

    df = dfview[['RteUid',	'RsgUid', 'txtDesig',	'txtLocDesig',	'DpnUidSta',	'NdbUidSta',	'VorUidSta',
                'DpnUidEnd', 'NdbUidEnd',	'VorUidEnd', 'codeIdSta',	'geoLatSta', 'geoLongSta',
                'codeIdEnd', 'geoLatEnd', 'geoLongEnd', 'valMagTrack',	'valReversMagTrack',	'valLen']]

    def latitude_dms_to_dd(dms_latitude):
        degrees = int(dms_latitude[0:2])
        minutes = int(dms_latitude[2:4])
        seconds = float(dms_latitude[4:-1])

        dd = degrees + minutes / 60 + seconds / 3600

        if dms_latitude[-1] == 'S':
            dd = -dd

        return dd

    def longitude_dms_to_dd(dms_longitude):
        degrees = int(dms_longitude[0:3])
        minutes = int(dms_longitude[3:5])
        seconds = float(dms_longitude[5:-1])

        dd = degrees + minutes / 60 + seconds / 3600

        if dms_longitude[-1] == 'W':
            dd = -dd

        return dd

    Df = df.copy()
    Df['geoLatSta'] = Df['geoLatSta'].apply(latitude_dms_to_dd)
    Df['geoLongSta'] = Df['geoLongSta'].apply(longitude_dms_to_dd)
    Df['geoLatEnd'] = Df['geoLatEnd'].apply(latitude_dms_to_dd)
    Df['geoLongEnd'] = Df['geoLongEnd'].apply(longitude_dms_to_dd)


    def calculate_declination(row, alt = 0 , date = magDateRef ):
        latitude, longitude = row
        return declination(latitude, longitude, alt, date)

    def true_bearing(x1, y1, x2, y2):
      # Convert latitude and longitude from degrees to radians
      l1 = math.radians(x1)
      L1 = math.radians(y1)
      l2 = math.radians(x2)
      L2 = math.radians(y2)

      # Calculate the difference in longitudes
      dlon = L2 - L1

      # Calculate the initial bearing (true heading)
      y = math.sin(dlon)
      x = math.cos(l1) * math.tan(l2) - math.sin(l1) * math.cos(dlon)
      initial_bearing = math.atan2(y, x)

      # Convert the initial bearing from radians to degrees
      initial_bearing = math.degrees(initial_bearing)

      # Ensure the bearing is in the range [0, 360]
      true_bearing = (initial_bearing + 360) % 360

      return true_bearing


    def calculate_distance(Df):
        coord1 = list(zip(Df['geoLatSta'], Df['geoLongSta']))
        coord2 = list(zip(Df['geoLatEnd'], Df['geoLongEnd']))

        # Utilisation de la bibliothèque geopy pour calculer la distance géodésique
        # Utilisation de la bibliothèque geopy pour calculer la distance géodésique et arrondir à zéro décimale
        Df['newValLen'] = [int(geodesic(c1, c2).meters / 1852.0 + 0.5) for c1, c2 in zip(coord1, coord2)]

        # Df['newValLen'] = [(geodesic(c1, c2).meters / 1852.0).round(0) for c1, c2 in zip(coord1, coord2)]

        return Df

    Df['declination_value1'] = Df[['geoLatSta', 'geoLongSta']].apply(calculate_declination, date = magDateRef, axis=1)
    Df['declination_value2'] = Df[['geoLatEnd', 'geoLongEnd']].apply(calculate_declination, date= magDateRef, axis=1)
    Df['newvalTrueTrack'] = Df.apply(lambda row: true_bearing(row['geoLatSta'], row['geoLongSta'], row['geoLatEnd'], row['geoLongEnd']), axis=1)
    Df['newvalMagTrack'] = ((Df['newvalTrueTrack'] - (Df['declination_value1'] + Df['declination_value2']) / 2).round(0))
    Df['newvalReverseMagTrack'] = Df['newvalMagTrack'] + 180
    # Vérifier si le résultat est supérieur à 360
    Df['newvalReverseMagTrack'] = Df['newvalReverseMagTrack'] - 360 * (Df['newvalReverseMagTrack'] > 360)

    calculate_distance(Df)

    DF = Df[['RteUid',	'RsgUid', 'txtDesig',	'txtLocDesig',	'DpnUidSta',	'NdbUidSta',	'VorUidSta',
                'DpnUidEnd', 'NdbUidEnd',	'VorUidEnd', 'codeIdSta',	'geoLatSta', 'geoLongSta',
                'codeIdEnd', 'geoLatEnd', 'geoLongEnd', 'valMagTrack', 'newvalMagTrack',	'valReversMagTrack','newvalReverseMagTrack', 'valLen', 'newValLen']]


    dfview_mag_divergents = DF[~(DF['valMagTrack']==DF['newvalMagTrack'])]
    rsg_incorrect_mag = dfview_mag_divergents.to_csv('Incorrect_Mag.csv', index=False)

    DF['valLen'].fillna(0, inplace=True)
    dfview_dist_divergents = DF[DF['valLen'].astype(int) != DF['newValLen'].astype(int)]
    rsg_incorrect_dist = dfview_dist_divergents.to_csv('Incorrect_Dist.csv', index=False)

    df_final = dfview.copy()

    # Identifiez les indices où les valeurs de 'valMagTrack' et 'ValLen' sont divergentes
    mag_indices_divergents = df_final.index[df_final['valMagTrack'] != DF['newvalMagTrack']]
    dist_indices_divergents = df_final.index[df_final['valLen'] != DF['newValLen']]

    # Mettez à jour les valeurs de 'valMagTrack' et 'ValLen' dans le DataFrame initial 'df'

    df_final.loc[mag_indices_divergents, 'valMagTrack'] = DF.loc[mag_indices_divergents, 'newvalMagTrack']
    df_final.loc[mag_indices_divergents, 'valReversMagTrack'] = DF.loc[mag_indices_divergents, 'newvalReverseMagTrack']
    df_final.loc[dist_indices_divergents, 'valLen'] = DF.loc[dist_indices_divergents, 'newValLen']

    # Export en csv
    rsg_csv = df_final.to_csv('Corrected_dataset.csv', index=False)

    # Export en xml
    # Créez un élément racine pour le nouveau fichier XML
    new_root = ET.Element("AIXM-Snapshot")
    new_root.set("created", "2023-10-20T19:22:44.725Z")
    new_root.set("origin", "Asecna")
    new_root.set("version", "4.5")
    new_root.set("effective", "2023-10-20T00:00:00.000Z")

    # Créez un élément Rsg pour chaque ligne de votre DataFrame
    for index, row in df_final.iterrows():
        rsg = ET.SubElement(new_root, "Rsg")

        rsg_uid = ET.SubElement(rsg, "RsgUid")
        rsg_uid.set("mid", str(row['RsgUid']))

        rte_uid = ET.SubElement(rsg_uid, "RteUid")
        rte_uid.set("mid", str(row['RteUid']))

        txt_desig = ET.SubElement(rte_uid, "txtDesig")
        txt_desig.text = str(row['txtDesig'])

        txt_loc_desig = ET.SubElement(rte_uid, "txtLocDesig")
        txt_loc_desig.text = str(row['txtLocDesig'])

        if str(row['DpnUidSta']) != "nan":
          dpn_uid_sta = ET.SubElement(rsg_uid, "DpnUidSta")
        # if dpn_uid_sta is not None:
          dpn_uid_sta.set("mid", str(row['DpnUidSta']))
          code_id_sta = ET.SubElement(dpn_uid_sta, "codeId")
          code_id_sta.text = str(row['codeIdSta'])
          geo_lat_sta = ET.SubElement(dpn_uid_sta, "geoLat")
          geo_lat_sta.text = str(row['geoLatSta'])
          geo_long_sta = ET.SubElement(dpn_uid_sta, "geoLong")
          geo_long_sta.text = str(row['geoLongSta'])

        if str(row['NdbUidSta']) != "nan":
          ndb_uid_sta = ET.SubElement(rsg_uid, "NdbUidSta")
        # if ndb_uid_sta is not None:
          ndb_uid_sta.set("mid", str(row['NdbUidSta']))
          code_id_sta = ET.SubElement(ndb_uid_sta, "codeId")
          code_id_sta.text = str(row['codeIdSta'])
          geo_lat_sta = ET.SubElement(ndb_uid_sta, "geoLat")
          geo_lat_sta.text = str(row['geoLatSta'])
          geo_long_sta = ET.SubElement(ndb_uid_sta, "geoLong")
          geo_long_sta.text = str(row['geoLongSta'])

        if str(row['VorUidSta']) != "nan":
          vor_uid_sta = ET.SubElement(rsg_uid, "VorUidSta")
        # if vor_uid_sta is not None:
          vor_uid_sta.set("mid", str(row['VorUidSta']))
          code_id_sta = ET.SubElement(vor_uid_sta, "codeId")
          code_id_sta.text = str(row['codeIdSta'])
          geo_lat_sta = ET.SubElement(vor_uid_sta, "geoLat")
          geo_lat_sta.text = str(row['geoLatSta'])
          geo_long_sta = ET.SubElement(vor_uid_sta, "geoLong")
          geo_long_sta.text = str(row['geoLongSta'])


        if str(row['DpnUidEnd']) != "nan":
          dpn_uid_end = ET.SubElement(rsg_uid, "DpnUidEnd")
        # if dpn_uid_end is not None:
          dpn_uid_end.set("mid", str(row['DpnUidEnd']))
          code_id_end = ET.SubElement(dpn_uid_end, "codeId")
          code_id_end.text = str(row['codeIdEnd'])
          geo_lat_end = ET.SubElement(dpn_uid_end, "geoLat")
          geo_lat_end.text = str(row['geoLatEnd'])
          geo_long_end = ET.SubElement(dpn_uid_end, "geoLong")
          geo_long_end.text = str(row['geoLongEnd'])

        if str(row['NdbUidEnd']) != "nan":
          ndb_uid_end = ET.SubElement(rsg_uid, "NdbUidEnd")
        # if ndb_uid_end is not None:
          ndb_uid_end.set("mid", str(row['NdbUidEnd']))
          code_id_end = ET.SubElement(ndb_uid_end, "codeId")
          code_id_end.text = str(row['codeIdEnd'])
          geo_lat_end = ET.SubElement(ndb_uid_end, "geoLat")
          geo_lat_end.text = str(row['geoLatEnd'])
          geo_long_end = ET.SubElement(ndb_uid_end, "geoLong")
          geo_long_end.text = str(row['geoLongEnd'])

        if str(row['VorUidEnd']) != "nan":
          vor_uid_end = ET.SubElement(rsg_uid, "VorUidEnd")
          # if vor_uid_end is not None:
          vor_uid_end.set("mid", str(row['VorUidEnd']))
          code_id_end = ET.SubElement(vor_uid_end, "codeId")
          code_id_end.text = str(row['codeIdEnd'])
          geo_lat_end = ET.SubElement(vor_uid_end, "geoLat")
          geo_lat_end.text = str(row['geoLatEnd'])
          geo_long_end = ET.SubElement(vor_uid_end, "geoLong")
          geo_long_end.text = str(row['geoLongEnd'])


        code_type = ET.SubElement(rsg, "codeType")
        code_type.text = str(row['codeType'])

        code_lvl = ET.SubElement(rsg, "codeLvl")
        code_lvl.text = str(row['codeLvl'])

        val_dist_ver_upper = ET.SubElement(rsg, "valDistVerUpper")
        val_dist_ver_upper.text = str(row['valDistVerUpper'])

        uom_dist_ver_upper = ET.SubElement(rsg, "uomDistVerUpper")
        uom_dist_ver_upper.text = str(row['uomDistVerUpper'])

        code_dist_ver_upper = ET.SubElement(rsg, "codeDistVerUpper")
        code_dist_ver_upper.text = str(row['codeDistVerUpper'])

        val_dist_ver_lower = ET.SubElement(rsg, "valDistVerLower")
        val_dist_ver_lower.text = str(row['valDistVerLower'])

        uom_dist_ver_lower = ET.SubElement(rsg, "uomDistVerLower")
        uom_dist_ver_lower.text = str(row['uomDistVerLower'])

        code_dist_ver_lower = ET.SubElement(rsg, "codeDistVerLower")
        code_dist_ver_lower.text = str(row['codeDistVerLower'])

        val_wid = ET.SubElement(rsg, "valWid")
        val_wid.text = str(row['valWid'])

        uom_wid = ET.SubElement(rsg, "uomWid")
        uom_wid.text = str(row['uomWid'])

        code_rep_atc_start = ET.SubElement(rsg, "codeRepAtcStart")
        code_rep_atc_start.text = str(row['codeRepAtcStart'])

        code_rep_atc_end = ET.SubElement(rsg, "codeRepAtcEnd")
        code_rep_atc_end.text = str(row['codeRepAtcEnd'])

        val_mag_track = ET.SubElement(rsg, "valMagTrack")
        val_mag_track.text = str(row['valMagTrack'])

        val_revers_mag_track = ET.SubElement(rsg, "valReversMagTrack")
        val_revers_mag_track.text = str(row['valReversMagTrack'])

        val_len = ET.SubElement(rsg, "valLen")
        val_len.text = str(row['valLen'])

        uom_dist = ET.SubElement(rsg, "uomDist")
        uom_dist.text = str(row['uomDist'])

    def indent(elem, level=0):
        i = "\n" + level * "  "
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = i + "  "
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
            for elem in elem:
                indent(elem, level + 1)
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
        else:
            if level and (not elem.tail or not elem.tail.strip()):
                elem.tail = i

    # Utilisez la fonction `indent` pour formater le fichier XML
    indent(new_root)

    # Créez un nouvel arbre XML à partir de la nouvelle structure
    new_tree = ET.ElementTree(new_root)

    # Enregistrez Sle nouvel arbre XML dans un fichier

    new_tree.write("Corrected_dataset.xml", xml_declaration=True, encoding="utf-8", method="xml")
        
    # Liste des noms de fichiers sauvegardés
    saved_files = [ 'Corrected_dataset.xml', 'Corrected_dataset.csv', 'Incorrect_Mag.csv', 'Incorrect_Dist.csv']

    return redirect(url_for('confirmation'))

@app.route('/download/<filename>')
def download_file(filename):
    try:
        return send_from_directory('./', filename, as_attachment=True)
    except Exception as e:
        return str(e), 404

@app.route('/confirmation', methods=['GET'])
def confirmation():
  saved_files = ['Corrected_dataset.xml', 'Corrected_dataset.csv', 'Incorrect_Mag.csv', 'Incorrect_Dist.csv']
  return render_template('confirmation.html', saved_files=saved_files)

@app.route('/calculs', methods=['POST'])
def calculs():
    if request.method == 'POST':
        data = request.form

        if 'lat1' in data and 'Lon1' in data and 'lat2' in data and 'Lon2' in data and 'year' in data and 'month' in data and 'day' in data:
            lat1 = data['lat1']
            Lon1 = data['Lon1']
            lat2 = data['lat2']
            Lon2 = data['Lon2']
            year = int(data['year'])
            month = int(data['month'])
            day = int(data['day'])

            def dms_to_dd(coord):
                # Divise la chaîne DMS en degrés, minutes et secondes
                parts = coord.split()
                degrees = float(parts[0])
                minutes = float(parts[1])
                seconds = float(parts[2])

                # Vérifie si degrees est négatif, ajuste la valeur en conséquence
                if coord.startswith("-"):
                    degrees = -degrees

                    # Calcule les coordonnées en DD
                    dd = -(degrees + minutes / 60 + seconds / 3600)
                else:

                    # Calcule les coordonnées en DD
                    dd = degrees + minutes / 60 + seconds / 3600

                return dd

            def calcul_declinaison_distance():
                l1 = dms_to_dd(lat1)
                L1 = dms_to_dd(Lon1)

                l2 = dms_to_dd(lat2)
                L2 = dms_to_dd(Lon2)

                date_2020 = datetime.date(year, month, day)

                # Calcul de la déclinaison magnétique
                declination_value1 = declination(l1, L1, 0,date_2020)
                declination_value2 = declination(l2, L2, 0,date_2020)

                # Fonction pour calculer la distance entre deux points géographiques

                coord1 = (l1, L1)
                coord2 = (l2, L2)

                # Utilisation de la bibliothèque geopy pour calculer la distance géodésique
                distance = geodesic(coord1, coord2).meters

                # Conversion de mètres en nautiques (1 nautique = 1852 mètres)
                distance_nautical_miles = distance / 1852.0

                return declination_value1, declination_value2, distance_nautical_miles

            def true_bearing():
                # Convert latitude and longitude from degrees to radians
                l1 = math.radians(dms_to_dd(lat1))
                L1 = math.radians(dms_to_dd(Lon1)                      )
                l2 = math.radians(dms_to_dd(lat2))
                L2 = math.radians(dms_to_dd(Lon2))

                # Calculate the difference in longitudes
                dlon = L2 - L1

                # Calculate the initial bearing (true heading)
                y = math.sin(dlon)
                x = math.cos(l1) * math.tan(l2) - math.sin(l1) * math.cos(dlon)
                initial_bearing = math.atan2(y, x)

                # Convert the initial bearing from radians to degrees
                initial_bearing = math.degrees(initial_bearing)

                # Ensure the bearing is in the range [0, 360]
                true_bearing = (initial_bearing + 360) % 360

                return true_bearing

            orientation_vraie = true_bearing()
            orientation_magnetique = orientation_vraie - (calcul_declinaison_distance()[0]+calcul_declinaison_distance()[1])/2
            distance = calcul_declinaison_distance()[2]
 

            result = {
                'orientation_vraie': '{:.0f}'.format(orientation_vraie),
                'orientation_magnetique': '{:.0f}'.format(orientation_magnetique),
                'distance_nautique': '{:.0f}'.format(distance),
            }

            return render_template('confirmation.html', result=result)
        else:
            return jsonify({'error': 'Données manquantes'})


@app.errorhandler(Exception)
def handle_exception(e):
    """ Capture toutes les erreurs et les renvoie sous forme JSON """
    app.logger.error(f"Erreur détectée : {e}")
    return jsonify({"error": "Une erreur est survenue.", "details": str(e)}), 500  
    
if __name__ == '__main__':
  app.run(debug=True)


